package sim

// Opcodes represents a list of
// available opcodes, and their
// matching Executor
type Opcodes = map[byte]func()

// InitOpcodes intializes all know opcodes
// with the given model
func InitOpcodes(m *Model) Opcodes {
	return map[byte]func(){
		0xad: func() { m.LDA(AResolver(m.NextWord()...)) },
		0xbd: func() { m.LDA(AXResolver(m.NextWord()...)) },
		0xb9: func() { m.LDA(AYResolver(m.NextWord()...)) },
		0xa9: func() { m.LDA(IResolver(m.NextByte())) },
		0xa5: func() { m.LDA(ZPResolver(m.NextByte())) },
		0xa1: func() { m.LDA(ZPIXResolver(m.NextByte())) },
		0xb5: func() { m.LDA(ZPXResolver(m.NextByte())) },
		0xb1: func() { m.LDA(ZPIYResolver(m.NextByte())) },
		0xae: func() { m.LDX(AResolver(m.NextWord()...)) },
		0xbe: func() { m.LDX(AYResolver(m.NextWord()...)) },
		0xa2: func() { m.LDX(IResolver(m.NextByte())) },
		0xa6: func() { m.LDX(ZPResolver(m.NextByte())) },
		0xb6: func() { m.LDX(ZPYResolver(m.NextByte())) },
		0xac: func() { m.LDY(AResolver(m.NextWord()...)) },
		0xbc: func() { m.LDY(AXResolver(m.NextWord()...)) },
		0xa0: func() { m.LDY(IResolver(m.NextByte())) },
		0xa4: func() { m.LDY(ZPResolver(m.NextByte())) },
		0xb4: func() { m.LDY(ZPXResolver(m.NextByte())) },
		0x8d: func() { m.STA(AResolver(m.NextWord()...)) },
		0x9d: func() { m.STA(AXResolver(m.NextWord()...)) },
		0x99: func() { m.STA(AYResolver(m.NextWord()...)) },
		0x85: func() { m.STA(ZPResolver(m.NextByte())) },
		0x81: func() { m.STA(ZPIXResolver(m.NextByte())) },
		0x95: func() { m.STA(ZPXResolver(m.NextByte())) },
		0x91: func() { m.STA(ZPIYResolver(m.NextByte())) },
		0x8e: func() { m.STX(AResolver(m.NextWord()...)) },
		0x86: func() { m.STX(ZPResolver(m.NextByte())) },
		0x96: func() { m.STX(ZPYResolver(m.NextByte())) },
		0x8c: func() { m.STY(AResolver(m.NextWord()...)) },
		0x84: func() { m.STY(ZPResolver(m.NextByte())) },
		0x94: func() { m.STY(ZPXResolver(m.NextByte())) },
		0x6d: func() { m.ADC(AResolver(m.NextWord()...)) },
		0x7d: func() { m.ADC(AXResolver(m.NextWord()...)) },
		0x79: func() { m.ADC(AYResolver(m.NextWord()...)) },
		0x69: func() { m.ADC(IResolver(m.NextByte())) },
		0x65: func() { m.ADC(ZPResolver(m.NextByte())) },
		0x61: func() { m.ADC(ZPIXResolver(m.NextByte())) },
		0x75: func() { m.ADC(ZPXResolver(m.NextByte())) },
		0x71: func() { m.ADC(ZPIYResolver(m.NextByte())) },
		0xed: func() { m.SBC(AResolver(m.NextWord()...)) },
		0xfd: func() { m.SBC(AXResolver(m.NextWord()...)) },
		0xf9: func() { m.SBC(AYResolver(m.NextWord()...)) },
		0xe9: func() { m.SBC(IResolver(m.NextByte())) },
		0xe5: func() { m.SBC(ZPResolver(m.NextByte())) },
		0xe1: func() { m.SBC(ZPIXResolver(m.NextByte())) },
		0xf5: func() { m.SBC(ZPXResolver(m.NextByte())) },
		0xf1: func() { m.SBC(ZPIYResolver(m.NextByte())) },
		0xee: func() { m.INC(AResolver(m.NextWord()...)) },
		0xfe: func() { m.INC(AXResolver(m.NextWord()...)) },
		0xe6: func() { m.INC(ZPResolver(m.NextByte())) },
		0xf6: func() { m.INC(ZPXResolver(m.NextByte())) },
		0xe8: func() { m.INX() },
		0xc8: func() { m.INY() },
		0xce: func() { m.DEC(AResolver(m.NextWord()...)) },
		0xde: func() { m.DEC(AXResolver(m.NextWord()...)) },
		0xc6: func() { m.DEC(ZPResolver(m.NextByte())) },
		0xd6: func() { m.DEC(ZPXResolver(m.NextByte())) },
		0xca: func() { m.DEX() },
		0x88: func() { m.DEY() },
		0x0e: func() { m.ASL(AResolver(m.NextWord()...)) },
		0x1e: func() { m.ASL(AXResolver(m.NextWord()...)) },
		0x0a: func() { m.ASL(nil) },
		0x06: func() { m.ASL(ZPResolver(m.NextByte())) },
		0x16: func() { m.ASL(ZPXResolver(m.NextByte())) },
		0x4e: func() { m.LSR(AResolver(m.NextWord()...)) },
		0x5e: func() { m.LSR(AXResolver(m.NextWord()...)) },
		0x4a: func() { m.LSR(nil) },
		0x46: func() { m.LSR(ZPResolver(m.NextByte())) },
		0x56: func() { m.LSR(ZPXResolver(m.NextByte())) },
		0x2e: func() { m.ROL(AResolver(m.NextWord()...)) },
		0x3e: func() { m.ROL(AXResolver(m.NextWord()...)) },
		0x2a: func() { m.ROL(nil) },
		0x26: func() { m.ROL(ZPResolver(m.NextByte())) },
		0x36: func() { m.ROL(ZPXResolver(m.NextByte())) },
		0x6e: func() { m.ROR(AResolver(m.NextWord()...)) },
		0x7e: func() { m.ROR(AXResolver(m.NextWord()...)) },
		0x6a: func() { m.ROR(nil) },
		0x66: func() { m.ROR(ZPResolver(m.NextByte())) },
		0x76: func() { m.ROR(ZPXResolver(m.NextByte())) },
		0x2d: func() { m.AND(AResolver(m.NextWord()...)) },
		0x3d: func() { m.AND(AXResolver(m.NextWord()...)) },
		0x39: func() { m.AND(AYResolver(m.NextWord()...)) },
		0x29: func() { m.AND(IResolver(m.NextByte())) },
		0x25: func() { m.AND(ZPResolver(m.NextByte())) },
		0x21: func() { m.AND(ZPIXResolver(m.NextByte())) },
		0x35: func() { m.AND(ZPXResolver(m.NextByte())) },
		0x31: func() { m.AND(ZPIYResolver(m.NextByte())) },
		0x0d: func() { m.ORA(AResolver(m.NextWord()...)) },
		0x1d: func() { m.ORA(AXResolver(m.NextWord()...)) },
		0x19: func() { m.ORA(AYResolver(m.NextWord()...)) },
		0x09: func() { m.ORA(IResolver(m.NextByte())) },
		0x05: func() { m.ORA(ZPResolver(m.NextByte())) },
		0x01: func() { m.ORA(ZPIXResolver(m.NextByte())) },
		0x15: func() { m.ORA(ZPXResolver(m.NextByte())) },
		0x11: func() { m.ORA(ZPIYResolver(m.NextByte())) },
		0x4d: func() { m.XOR(AResolver(m.NextWord()...)) },
		0x5d: func() { m.XOR(AXResolver(m.NextWord()...)) },
		0x59: func() { m.XOR(AYResolver(m.NextWord()...)) },
		0x49: func() { m.XOR(IResolver(m.NextByte())) },
		0x45: func() { m.XOR(ZPResolver(m.NextByte())) },
		0x41: func() { m.XOR(ZPIXResolver(m.NextByte())) },
		0x55: func() { m.XOR(ZPXResolver(m.NextByte())) },
		0x51: func() { m.XOR(ZPIYResolver(m.NextByte())) },
		0xcd: func() { m.CMP(AResolver(m.NextWord()...)) },
		0xdd: func() { m.CMP(AXResolver(m.NextWord()...)) },
		0xd9: func() { m.CMP(AYResolver(m.NextWord()...)) },
		0xc9: func() { m.CMP(IResolver(m.NextByte())) },
		0xc5: func() { m.CMP(ZPResolver(m.NextByte())) },
		0xc1: func() { m.CMP(ZPIXResolver(m.NextByte())) },
		0xd5: func() { m.CMP(ZPXResolver(m.NextByte())) },
		0xd1: func() { m.CMP(ZPIYResolver(m.NextByte())) },
		0xec: func() { m.CPX(AResolver(m.NextWord()...)) },
		0xe0: func() { m.CPX(IResolver(m.NextByte())) },
		0xe4: func() { m.CPX(ZPResolver(m.NextByte())) },
		0xcc: func() { m.CPY(AResolver(m.NextWord()...)) },
		0xc0: func() { m.CPY(IResolver(m.NextByte())) },
		0xc4: func() { m.CPY(ZPResolver(m.NextByte())) },
		0x2c: func() { m.BIT(AResolver(m.NextWord()...)) },
		0x89: func() { m.BIT(IResolver(m.NextByte())) },
		0x24: func() { m.BIT(ZPResolver(m.NextByte())) },
		0x90: func() { m.BCC(m.NextByte()) },
		0xb0: func() { m.BCS(m.NextByte()) },
		0xd0: func() { m.BNE(m.NextByte()) },
		0xf0: func() { m.BEQ(m.NextByte()) },
		0x10: func() { m.BPL(m.NextByte()) },
		0x30: func() { m.BMI(m.NextByte()) },
		0x50: func() { m.BVC(m.NextByte()) },
		0x70: func() { m.BVS(m.NextByte()) },
		0xaa: func() { m.TAX() },
		0x8a: func() { m.TXA() },
		0xa8: func() { m.TAY() },
		0x98: func() { m.TYA() },
		0xba: func() { m.TSX() },
		0x9a: func() { m.TXS() },
		0x48: func() { m.PHA() },
		0x68: func() { m.PLA() },
		0x08: func() { m.PHP() },
		0x28: func() { m.PLP() },
		0x4c: func() { m.JMP(JMPAResolver(m.NextWord()...)) },
		0x6c: func() { m.JMP(JMPAIResolver(m.NextWord()...)) },
		0x20: func() { m.JSR(m.NextWord()...) },
		0x60: func() { m.RTS() },
		0x40: func() { m.RTI() },
		0x18: func() { m.CLC() },
		0x38: func() { m.SEC() },
		0xd8: func() { m.CLD() },
		0xf8: func() { m.SED() },
		0x58: func() { m.CLI() },
		0x78: func() { m.SEI() },
		0xb8: func() { m.CLV() },
		0x00: func() { m.BRK() },
		0xea: func() { m.NOP() },
	}
}
